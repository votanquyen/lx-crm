/**
 * Migration Script: Transform real data from neon_complete.sql to Prisma v4 schema
 *
 * Mapping:
 * - companies ‚Üí customers
 * - invoices (old) ‚Üí invoices (new)
 * - monthly_statements ‚Üí preserved as reference data
 * - plant_items ‚Üí preserved as reference data
 *
 * Run: pnpm tsx scripts/migrate-real-data.ts
 */
import { PrismaClient } from "@prisma/client";
import fs from "fs";
import path from "path";
import crypto from "crypto";

const prisma = new PrismaClient();

// Simple CUID-like generator (Prisma handles this, but we need it for invoiceNumber)
function generateId(): string {
  return crypto.randomBytes(12).toString("hex").slice(0, 8);
}

// ============================================================
// DATA EXTRACTED FROM neon_complete.sql
// ============================================================

interface OldCompany {
  id: string;
  name: string;
  short_name: string;
  address: string | null;
  district: string | null;
  contact_name: string | null;
  contact_phone: string | null;
}

interface OldInvoice {
  id: string;
  company_id: string | null;
  company_name_raw: string | null;
  year: number;
  month: number;
  invoice_number: string | null;
  content: string | null;
  amount_before_vat: number;
  vat: number;
  total: number;
  payment_date: string | null;
  status: "pending" | "paid" | "cancelled";
}

// ============================================================
// PARSE SQL FILE
// ============================================================

function parseSqlFile(): { companies: OldCompany[]; invoices: OldInvoice[] } {
  const sqlPath = path.join(process.cwd(), "plans/realdb/neon_complete.sql");
  const sqlContent = fs.readFileSync(sqlPath, "utf-8");

  const companies: OldCompany[] = [];
  const invoices: OldInvoice[] = [];

  // Parse companies
  const companyRegex =
    /INSERT INTO companies \(id, name, short_name, address, district, contact_name, contact_phone\) VALUES \('([^']+)', '([^']*)', '([^']*)', (?:'([^']*)'|NULL), (?:'([^']*)'|NULL), (?:'([^']*)'|NULL), (?:'([^']*)'|NULL)\);/g;

  let match;
  while ((match = companyRegex.exec(sqlContent)) !== null) {
    companies.push({
      id: match[1],
      name: match[2],
      short_name: match[3],
      address: match[4] || null,
      district: match[5] || null,
      contact_name: match[6] || null,
      contact_phone: match[7] || null,
    });
  }

  // Parse invoices - more complex pattern
  const invoiceRegex =
    /INSERT INTO invoices \(id, company_id, company_name_raw, year, month, invoice_number, content, amount_before_vat, vat, total, payment_date, status\) VALUES \('([^']+)', (?:'([^']*)'|NULL), (?:'([^']*)'|NULL), (\d+), (\d+), (?:'([^']*)'|NULL), (?:'([^']*)'|NULL), (\d+), (\d+), (\d+), (?:'([^']*)'|NULL), '([^']+)'\);/g;

  while ((match = invoiceRegex.exec(sqlContent)) !== null) {
    invoices.push({
      id: match[1],
      company_id: match[2] || null,
      company_name_raw: match[3] || null,
      year: parseInt(match[4]),
      month: parseInt(match[5]),
      invoice_number: match[6] || null,
      content: match[7] || null,
      amount_before_vat: parseInt(match[8]),
      vat: parseInt(match[9]),
      total: parseInt(match[10]),
      payment_date: match[11] || null,
      status: match[12] as "pending" | "paid" | "cancelled",
    });
  }

  console.log(`Parsed ${companies.length} companies, ${invoices.length} invoices`);
  return { companies, invoices };
}

// ============================================================
// MIGRATION FUNCTIONS
// ============================================================

async function migrateCompaniesToCustomers(companies: OldCompany[]) {
  console.log("\nüì¶ Migrating companies ‚Üí customers...");

  let created = 0;
  let skipped = 0;

  for (let i = 0; i < companies.length; i++) {
    const company = companies[i];
    const code = `KH-${String(i + 1).padStart(3, "0")}`;

    try {
      // Check if already exists by name
      const existing = await prisma.customer.findFirst({
        where: { companyName: company.name },
      });

      if (existing) {
        skipped++;
        continue;
      }

      await prisma.customer.create({
        data: {
          // id auto-generated by Prisma (cuid)
          code,
          companyName: company.name,
          shortName: company.short_name,
          address: company.address || "ƒê·ªãa ch·ªâ ch∆∞a c·∫≠p nh·∫≠t",
          district: company.district,
          city: "H·ªì Ch√≠ Minh",
          contactName: company.contact_name,
          contactPhone: company.contact_phone,
          status: "ACTIVE",
          tier: "STANDARD",
        },
      });
      created++;
    } catch (error) {
      console.error(`  ‚ùå Error migrating company ${company.name}:`, error);
    }
  }

  console.log(`  ‚úÖ Created: ${created}, Skipped: ${skipped}`);
}

async function migrateInvoices(invoices: OldInvoice[], companyIdMap: Map<string, string>) {
  console.log("\nüìÑ Migrating invoices...");

  let created = 0;
  let skipped = 0;

  for (const invoice of invoices) {
    // Generate invoice number if missing
    const invoiceNumber =
      invoice.invoice_number ||
      `INV-${invoice.year}${String(invoice.month).padStart(2, "0")}-${generateId().toUpperCase()}`;

    try {
      // Check if already exists
      const existing = await prisma.invoice.findFirst({
        where: { invoiceNumber },
      });

      if (existing) {
        skipped++;
        continue;
      }

      // Find customer by old company_id
      let customerId: string | null = null;
      if (invoice.company_id) {
        customerId = companyIdMap.get(invoice.company_id) || null;
      }

      // If no customer found, try to find by company_name_raw
      if (!customerId && invoice.company_name_raw) {
        const customer = await prisma.customer.findFirst({
          where: { companyName: { contains: invoice.company_name_raw.split(" ")[0] } },
        });
        customerId = customer?.id || null;
      }

      // Skip if no customer found (orphan invoice)
      if (!customerId) {
        console.warn(`  ‚ö†Ô∏è No customer for invoice ${invoiceNumber}`);
        skipped++;
        continue;
      }

      // Map old status to new status
      const statusMap: Record<string, "DRAFT" | "SENT" | "PAID" | "CANCELLED" | "OVERDUE"> = {
        pending: "SENT",
        paid: "PAID",
        cancelled: "CANCELLED",
      };

      const periodStart = new Date(invoice.year, invoice.month - 1, 1);
      const periodEnd = new Date(invoice.year, invoice.month, 0);
      const dueDate = new Date(invoice.year, invoice.month, 15); // Due 15th of next month

      await prisma.invoice.create({
        data: {
          // id auto-generated by Prisma (cuid)
          invoiceNumber,
          customerId,
          invoiceType: "service",
          periodStart,
          periodEnd,
          periodLabel: `Th√°ng ${String(invoice.month).padStart(2, "0")}/${invoice.year}`,
          subtotal: invoice.amount_before_vat,
          vatRate: invoice.vat > 0 ? 8 : 0,
          vatAmount: invoice.vat,
          totalAmount: invoice.total,
          paidAmount: invoice.status === "paid" ? invoice.total : 0,
          outstandingAmount: invoice.status === "paid" ? 0 : invoice.total,
          status: statusMap[invoice.status] || "SENT",
          issueDate: periodStart,
          dueDate,
          paidDate: invoice.payment_date ? new Date(invoice.payment_date) : null,
          notes: invoice.content,
        },
      });
      created++;
    } catch (error) {
      console.error(`  ‚ùå Error migrating invoice:`, error);
    }
  }

  console.log(`  ‚úÖ Created: ${created}, Skipped: ${skipped}`);
}

// ============================================================
// MAIN
// ============================================================

async function main() {
  console.log("üöÄ Starting migration from neon_complete.sql to Prisma v4 schema\n");

  // Parse SQL file
  const { companies, invoices } = parseSqlFile();

  // Migrate companies ‚Üí customers
  await migrateCompaniesToCustomers(companies);

  // Build mapping: old UUID ‚Üí new CUID
  const companyIdMap = new Map<string, string>();
  const customers = await prisma.customer.findMany();

  for (const company of companies) {
    const customer = customers.find((c) => c.companyName === company.name);
    if (customer) {
      companyIdMap.set(company.id, customer.id);
    }
  }

  console.log(`\nüîó Mapped ${companyIdMap.size} company IDs`);

  // Migrate invoices
  await migrateInvoices(invoices, companyIdMap);

  // Summary
  const customerCount = await prisma.customer.count();
  const invoiceCount = await prisma.invoice.count();

  console.log("\n" + "=".repeat(50));
  console.log("‚úÖ MIGRATION COMPLETE");
  console.log("=".repeat(50));
  console.log(`Customers: ${customerCount}`);
  console.log(`Invoices: ${invoiceCount}`);
}

main()
  .catch((e) => {
    console.error("Migration failed:", e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
